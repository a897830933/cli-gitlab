// Generated by CoffeeScript 1.7.1
var checkOptions, configFilePath, fs, gitlab, gitlabDircPath, nconf, path, requireOrGetGitlab, _;

nconf = require("nconf");

fs = require("fs");

path = require("path");

_ = require("underscore");

gitlabDircPath = path.join(process.env[(process.platform === "win32" ? "USERPROFILE" : "HOME")], ".gitlab");

if (!fs.existsSync(gitlabDircPath)) {
  fs.mkdirSync(gitlabDircPath);
}

configFilePath = path.join(gitlabDircPath, "config.json");

nconf.file({
  file: configFilePath
});

gitlab = null;

checkOptions = function() {
  if (!nconf.get("url")) {
    console.log("You should set url by 'gitlab url http://example.com' ");
    return false;
  }
  if (!nconf.get("token")) {
    console.log("You should set token by 'gitlab token abcdefghij123456' ");
    return false;
  }
  return true;
};

requireOrGetGitlab = function() {
  if (gitlab != null) {
    return gitlab;
  } else {
    if (checkOptions()) {
      gitlab = require("gitlab")({
        url: nconf.get("url"),
        token: nconf.get("token")
      });
      return gitlab;
    }
  }
};

exports.url = function(url) {
  if (url != null) {
    nconf.set("url", url);
    nconf.save();
    return console.log("Save url");
  } else {
    return console.log(nconf.get("url"));
  }
};

exports.token = function(token) {
  if (token != null) {
    nconf.set("token", token);
    nconf.save();
    return console.log("Save token");
  } else {
    return console.log(nconf.get("token"));
  }
};

exports.getOption = function() {
  var key, opitons, value, _results;
  opitons = nconf.get();
  _results = [];
  for (key in opitons) {
    value = opitons[key];
    _results.push(console.log("" + key + ":" + value));
  }
  return _results;
};

exports.createOptions = function(program, param) {
  var key, value, _results;
  _results = [];
  for (key in param) {
    value = param[key];
    _results.push(program.option((value.alias != null ? "-" + value.alias + "," : "") + (" --" + key + " " + value.param), value.desc));
  }
  return _results;
};

exports.createParam = function(params) {
  var item, ret, _i, _len;
  if (params == null) {
    return "";
  }
  ret = [];
  for (_i = 0, _len = params.length; _i < _len; _i++) {
    item = params[_i];
    ret.push(item);
  }
  return ret.join(" ");
};

exports.createCommands = function(map, program) {
  return _.forEach(map, function(cmd, key) {
    var command;
    command = program.command("" + key + " " + (exports.createParam(cmd.param)));
    command.description(cmd.desc);
    if (cmd.filter === true) {
      cmd.options.filter = {
        param: "[filter]",
        type: true,
        desc: "(optional) - Filter result. For example: --filter 'item.assignee.id == 9' "
      };
    }
    if (cmd.options != null) {
      exports.createOptions(command, cmd.options);
    }
    return command.action(function() {
      var arg, fn, i, name, nameSpaces, options, target, value, _i, _len, _ref;
      options = arguments[arguments.length - 1] || {};
      arg = [];
      if ((cmd.param != null) && typeof arguments[0] !== "object") {
        i = 0;
        while (typeof arguments[i] !== "object") {
          arg.push(arguments[i]);
          i++;
        }
      }
      _ref = cmd.options;
      for (key in _ref) {
        value = _ref[key];
        if (value.index == null) {
          continue;
        }
        if (value.type) {
          if (arg[value.index] == null) {
            arg[value.index] = {};
          }
          if (options[key] != null) {
            arg[value.index][key] = options[key];
          }
        } else {
          if (options[key] != null) {
            arg[value.index] = options[key];
          }
        }
      }
      target = requireOrGetGitlab();
      nameSpaces = cmd.nameSpaces.split(".");
      fn = nameSpaces.pop();
      if (cmd.callback != null) {
        if (cmd.filter === true && (options != null) && (options.filter != null)) {
          cmd.callback = _.wrap(cmd.callback, function(fn, data) {
            var evalFn, evalFnString;
            evalFnString = "(function(item){ return " + options.filter + "; });";
            evalFn = eval(evalFnString);
            data = _.filter(data, evalFn);
            return fn(data);
          });
        }
        arg.push(cmd.callback);
      }
      for (_i = 0, _len = nameSpaces.length; _i < _len; _i++) {
        name = nameSpaces[_i];
        target = target[name];
      }
      return target[fn].apply(target, arg);
    });
  });
};

exports.url = function(url) {
  if (url != null) {
    nconf.set("url", url);
    nconf.save();
    return console.log("Save url");
  } else {
    return console.log(nconf.get("url"));
  }
};

exports.token = function(token) {
  if (token != null) {
    nconf.set("token", token);
    nconf.save();
    return console.log("Save token");
  } else {
    return console.log(nconf.get("token"));
  }
};

exports.getOption = function() {
  var key, opitons, value, _results;
  opitons = nconf.get();
  _results = [];
  for (key in opitons) {
    value = opitons[key];
    _results.push(console.log("" + key + ":" + value));
  }
  return _results;
};
